#![no_std]
#![no_main]

mod interrupts;
mod log;
mod sbi;
mod timer;
mod trap_handler;

use core::{
    arch::{asm, global_asm},
    panic::PanicInfo,
    sync::atomic::Ordering,
};

use timer::new_timer_in;
use trap_handler::{trap_handler, TIMER_FIRE};

// ; This is the section that we mapped first in the linker script `linker.ld`
// .section .text.boot
//
// ; Export the `_boot` symbol, now referenced in the linker script
// .global _boot
//
// ; Define the `_boot` symbol
// _boot:
//     ; set the stack pointer to the top of the stack
//     ; `_stack_top` is set by the linker
//     la sp, _stack_top
//     ; call into the kernel
//     call _start
global_asm!(
    ".section .text.boot",
    ".global _boot",
    "_boot:",
    "   la sp, _stack_top",
    "   call _start", // can use `tail` here because _start never returns hence we don't need to
                      // store the return address
);

#[unsafe(no_mangle)]
extern "C" fn _start(hart_id: usize, dtb_addr: usize) -> ! {
    log!("Hello from Lemon Shark: v0.0.{}\n", 1);

    log!("Got hart_id={hart_id}\n");
    log!("Got dtb_addr={dtb_addr}\n");

    unsafe extern "C" {
        static _trap_stack_top: u8;
    }

    // Set the `sscratch` register to a 'known good' stack that the `trap_handler can use`.
    unsafe {
        let trap_stack = &_trap_stack_top as *const u8 as usize;
        asm!("csrw sscratch, {}", in(reg) trap_stack);
    }

    trap_handler::init();
    interrupts::init();
    timer::init(dtb_addr);

    new_timer_in(3);

    log!("Bye :^)\n");

    log!("trap_handler addr: {:#x}\n", trap_handler as usize);

    let stvec: usize;
    unsafe {
        asm!("csrr {}, stvec", out(reg) stvec);
    }
    log!("stvec value: {:#x}\n", stvec);
    loop {
        if TIMER_FIRE.load(Ordering::Acquire) {
            TIMER_FIRE.store(false, Ordering::Release);
            // log!("Timer fired\n");
        }
    }
}

#[panic_handler]
fn panic_handler(info: &PanicInfo) -> ! {
    unsafe {
        let uart = 0x10000000 as *mut u8;
        uart.write_volatile(b'P');
        uart.write_volatile(b'A');
        uart.write_volatile(b'N');
        uart.write_volatile(b'I');
        uart.write_volatile(b'C');
        uart.write_volatile(b'\n');
    }
    // log!("Oh shit! {info:?}");
    loop {}
}
